# いろんなメモを書き連ねていく

## 設計ポリシーどうしようね...?

割とわかりやすい目標で行くなら並列化、実装としてはスタックを複数用意して...とかになるんだろうが、
あらかじめ配列とかの構造がないと効果が薄そう。

## 配列

実装方針とかどうしよう、そもそも

1. 人間が読める高級言語があって
2. それをいい感じに自作アーキテクチャに落として
3. それの動作を定義したプログラムを書く

って感じになるんだろうけど、配列の実装が 1 ⇔ 2 間でやるものであって今回実装しているのが 3 だからなぁという感じはする。
https://asasaki.cis.k.hosei.ac.jp/lect/compiler/2009A/2009-0615-VM.pdf
http://www.hpcs.cs.tsukuba.ac.jp/~msato/lecture-note/comp-lecture/note8.html
https://sylph.fuis.u-fukui.ac.jp/~moris/lecture/ARC/2020/ISA.pdf

## ループ

とりあえず、ループを作るためには命令列が保存されてあったほうが楽そう。
(私が考えたものの中だと)ループの終わりのJumpのアドレスを実行時に決めきれない(?)
なので**アーキテクチャとして命令列メモリが存在します!**、**実行前処理としてそこに命令列読み込みます!** とする。

### ラベル

ジャンプ命令や関数呼び出しのためにラベルがほしい、_labels というメモリ領域を
用意してそこにとび先アドレスを保持することにした。

![labelsの仕様]("./img/labels.png")

### JPEQ0

ループから抜け出すために作成、スタックの一番上に積まれているものが0なら指定番地にジャンプ。(判定が 0 なのは数値一致がそのほうが判定しやすいから)

## if判定

if文を直接記述するのはもうちょっと高級な言語でやるほうがいい気がする。
(高級にすると別途パーサーが必要になるのでちょっと無理)。

なので疑似的に if を意味するセットを考える。

今スタックの上に積まれている数字が n か判定したいとき
(今スタックには数字aが1つ積まれているとする)

```txt
STORE a
PUSH n
SUB      // a - n
JPEQ0 とび先ラベル
LOAD a                  // こっちがfalse
何らかの処理
JUMP 脱出ラベル
LABEL とび先ラベル
LOAD a                  // こっちがtrue
何らかの処理
LABEL 脱出ラベル
続きの処理               // if脱出
```

なんか長くなっていやだなぁという気がしなくもないが、実装が楽なのでこうした。

## ストア命令

仮想的に、変数とその値が入っているテーブルを定義している。

```C++
std::vector<unsigned int> _variables;        /// 変数ラベルとその値が入っている
```

ストア命令では、指定された番地に現在のスタックの一番上にあるものを移動する(popは行わない)。
なお、_variables の最大サイズは unsigned short の最大値(USHRT_MAX+1 = 65535+1)とする。理由としては命令定義時のオペランドが unsigned short として扱われるから。

## ロード命令

ロード命令では、指定された番地から取得した値を現在のスタックの一番上に値を積む。
この時、指定された番地がもともと定義されていなかった場合(つまりスコープ外や未定義)
についても 0 が帰り、エラー終了などはされないものとする(なぜなら実装が簡単だから)。

### 変数の扱いについて

ロード、ストアに変数名を使えるようにしたほうがコーディングがしやすい。
ほんとは高級言語⇒スタックマシン言語の変換の際にテーブル作って番号割り当てて、
スタックマシン言語中では番号しか使わないってほうがいいんだろうけど、高級言語を
定義するのがめんどくさかったので変数名をハッシュ化して_variableへの添え字番号にした。
多分結構衝突する。

## コメント

デバッグがしづらったので作成。

```txt
#コメントをここに挿入
```

みたいに記述するとその行を無視してくれる。
\#とコメントの間に空白を入れるとうまく動かないので注意。

## アーキテクチャ仕様

### _instructions に入れる命令列フォーマット

全体が unsigned shortで、オペコード(16 bit) + オペランド(16 bit)の構成。
効率考えたらオペコードのサイズとかもう少し小さくしてもよかったけど、実装が楽だったので。
